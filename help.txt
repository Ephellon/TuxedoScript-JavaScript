/********
---- Tuxedo Baseline ----
  -- Special --
<$n> ... </$n> - no.t.ch, any code put between the tags will be treated as native JS
<$s> ... </$s> - so.t.ch, any code put between the tags will be parsed as some TS, then JS
<$t> ... </$t> - to.t.ch, no need, just a proposal

  -- Comments --
## - single line comment, or multi-line comment ender
#* - multi-line starter
#*# - multi-line starter (author)
  @aut - author
  @lie - license
  @dat - date
  @tie - time
  @url - url
  @ver - version
##! - strict mode
## +attribute - enable an attribute
  can be: advance clean eval hide html-editor js-editor legacy math ugly wordy
## -attribute - disable an attribute
  can be: advance clean eval hide html-editor js-editor legacy math ugly wordy
## *a: b - replace all $a with b
## **a: b - replace all $a with parsed b

  -- Sequences and Strings --
\c - escape character, for use in/out of strings
  can be: / \ & ? : ; . @ # % $
$  - escape sequence for use in strings /notice the space/
` - \' if inside of a string, else '

  -- Variables --
#a - var a
a--b - a_b
a#b - a[b]
a#00 - a[a.length - 1]
@ - this
@a - this.a
$of - typeof
$del - delete
$args - arguments
$doc - document
$win - window
$nav - navigator
$loc - location
$cont - continue
$con - console
$# - Object
  $Obj - Object
  $obj - Object
.$id - getElementById
.$class - getElementsByClassName
.$tag - getElementsByTagName
.$html - innerHTML
.$text - innerText
.$val - value
.$qy - querySelector
.$Qy - querySelectorAll
a: b - if there isn't a comma after b, there will be one added, ubless b is the last item

  -- functions --
<- - return
$a b, c, d - function a(b, c, d)
 :$a, b, c - function(a, b, c)
 =$a, b, c - function(a, b, c)
 ,$a, b, c - function(a, b, c)
$: - function()
 ${ - function()

  -- Loops and Statements --
a?? - test if a exsists
a!?? - test if a doesn't exist

?a: - if a
  ?a { - if a
:: - else
  }{ - else
:?a: - else if a
  }?a{ - else if a

?#a, b - for a, to b by 1
  ?#a, b, c - for a = b, to c by 1
  ?#a, b, c, d - for a = b, to c, by d
-?#a, b - for a, to b by -1
  -?#a, b, c - for a = b, to c by -1
  -?#a, b, c, d - for a = b, to c, by d

?#a:b - for a in b
?#a:b ? c - for a, to b by 1, do c

?: - do
?a; - while a

?(a) - switch a
@def - default
@a: - case a

---- Advance features ----
.a - class x
.a b - class a extends y
*. - super
@(a, b, c) - constructor(a, b, c)
b => a - const a = b
a --> b - a = () => b
-> - =>
$*a, b, c: - void function(a, b, c)
  $*a, b, c { - void function(a, b, c)
prom a = (promise, signature, lease) - creates a promissory variable

---- Legacy features ----
a &= b - a = a && b
a |= b - a = a || b
a ^= b - if a != null, a = b
a ?= b - if a == null, a = b
a[b..c] - a.slice(b, c)
a[..c] - a.slice(0, c)
a[b..] - a.slice(b)
a[.] - a.slice(0)
a[*] - a.split("")
d[] - if d is a digit, it creates a d-dimension array, i.e. 3[] === [[[]]] /called on as [x][y][z]/
d{} - if d is a digit, it creates a d-dimension array, i.e. 3{} === {{{}}} /called on as x.$.y.$.z.$/
r:a - if r is a reserved word, it will be double-quoted
  .r - if r is a reserved word, it will be double-quoted and bracketized; ["r"]
"${a}" - interpolation, ..." + a + "...
'${a}' - interpolation, ...' + a + '...
`${a}` - interpolation, ...' + a + '...

---- Math features ----
a(b) = c - function a(b){ return c; }
da - if d is a number, then d * a
a~b - ((a % b + b) % b)
|a| - Math.abs(a)
a^b - Math.pow(a, b)
  a**b - Math.pow(a, b)
\a\ - Math.sqrt(a)
a\b\ - "a" root of b, i.e. 3\x\ is the cube root of x
a _ b - Math.floor(a/b) /notice the spaces/
log a (b) - log, base a, of b /log(b) / log(a)/
%property - Math.property, i.e. %PI = Math.PI, %log = Math.log

---- Wordy features ----
  -- Loops and Statements --
a exists - test if a exsists
  a exist - test if a exists
a !exists - test if a doesn't exist
  a !exist - test if a doesn't exist

if a: - if a
  if a { - if a
else - automatic braces for else
else-if a: - else if a
  else-if a { - else if a
  else-when a: - else if a
  else-when a { - else if a
  else-where a: - else if a
  else-where a { - else if a
if a then b else c - terenary operator, (a)?b:c

for a, b - for a, to b by 1
  for a, b, c - for a = b, to c by 1
  for a, b, c, d - for a = b, to c, by d
-for a, b - for a, to b by -1
  -for a, b, c - for a = b, to c by -1
  -for a, b, c, d - for a = b, to c, by d

for a: b - for a in b
  for a in b - for a in b
for a: b? c - for a, to b by 1, do c
  for a in b do c

do: - do
  do - do
while a; - while a
until a; - while !a

switch a - switch a

a(b) from c while d - for each item in c, if d is true, do b = c[...], a(b)
a(b) from c - for each item in c, do b = c[...], a(b)
a() from b while c - for each item in b, if c is true, do a

  -- Baseline --
#r - if r is a Tuxedo reserved word, then it will be a variable
  \r - if r is a Tuxedo reserved word, then it will be a variable
AND - &&
OR - ||
XOR - ^
NOT - !
  does not - !
  do not - !
  doesnt - !
does - !!
on - true
  yes - true
  good - true
off - false
  no - false
  bad - false
is not - !==
  isnt - !==
equals - ===
  equal - ===
  is - ===
a = b in c - a = c[b]
a = b from c - a  = c.indexOf(b)
<?> - ? hangar
<!> - ! hangar
<#> - # hangar

---- Ugly features ----
single line comments become multi-line
undefined - void 0
true - !0
  !false - !0
  !!true - !0
false - !1
  !true - !1
  !!false - !1
Number(a) - (+a)
a.toString() - a + ""
while(x) - for(;x;)
multiple zeros are "crunched" down to a 1eX form, i.e. 10000000 = 1e7

---- Advance + Legacy features ----
  -- Splats --
$a b... - same as b = arguments
$a b, c... - c will be all arguments after b
$a b..., c - b will be all arguments before c
$a b, c..., d - c will be al arguments between b and d
a(b...) - same as a(b) uses .apply
a(b, c...) - a([b c]) uses .apply
a(b..., c) - a([b c]) uses .apply
a(b, c..., d) - a([b c d]) uses .apply
<@> - @ hangar

---- Hangars ----
! - "index_counter"
@ - "arguments"
# - "undefined"
? - "ANON"

---- Methods ----
* $ means executable
* tuxedo === tux
tux
  get
    form
$     data - get form data from the URI
  storage
$   set[...] - set the local storage [name, data, name, data ...]
$   check[name] - see if the local storage at the name exists
$   get[name] - get the local storage at the name
$   delete[name] - delete the local storage at the name
$ attr[element, attribute, value] - set the attribute as the value
$ id[element, attribute, value] - set the attribute as the value
  $ id[element, html] - set the innerHTML as the value
  $ id[element] - just return the element, by id
$ class[element, attribute, value] - set the attribute as the value
  $ class[element, html] - set the innerHTML as the value
  $ class[element] - just return the element, by class name
$ tag[element, attribute, value] - set the attribute as the value
  $ tag[element, html] - set the innerHTML as the value
  $ tag[element] - just return the element, by tag name
$ ele[element, number, attribute, value] - set the attribute as the value
  $ ele[element, number, html] - set the innerHTML as the value
  $ ele[element, number] - just return the element, by element name (via querySelector)
$ save[data, name] - tux.storage.set(name, data)
$ load[name] - tux.storage.get(name)
$ delete[name] - tux.storage.delete(name)
********/